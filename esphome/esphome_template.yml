esphome:
  name: esphome-web-2e51ac
  friendly_name: ESP32C3-Toslink-Switch
  min_version: 2025.11.0
  name_add_mac_suffix: false

esp32:
  board: esp32-c3-devkitm-1
  variant: ESP32C3
  framework:
    type: arduino

# Enable logging
logger:

# Enable Home Assistant API
api:

# Allow Over-The-Air updates
ota:
- platform: esphome

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

web_server:
  port: 80


switch:
  - platform: gpio
    id: switch_ab
    pin:
      number: 4
      mode:
        output: true
    name: "Switch CH A/B"

number:
  - platform: template
    name: "Frequency Threshold CH A"
    id: freq_threshold_ch_a
    optimistic: true
    min_value: 100
    max_value: 2000
    step: 25
    initial_value: 100
    restore_value: true
    mode: box

  - platform: template
    name: "Frequency Threshold CH B"
    id: freq_threshold_ch_b
    optimistic: true
    min_value: 100
    max_value: 2000
    step: 25
    initial_value: 100
    restore_value: true
    mode: box

  - platform: template
    name: "Switching Time CH A"
    id: switching_time_ch_a
    optimistic: true
    min_value: 500
    max_value: 4000
    step: 500
    initial_value: 500
    restore_value: true
    mode: box

  - platform: template
    name: "Switching Time CH B"
    id: switching_time_ch_b
    optimistic: true
    min_value: 500
    max_value: 4000
    step: 500
    initial_value: 500
    restore_value: true
    mode: box

sensor:
  - platform: pulse_counter
    id: pulse_counter_a
    pin:
      number: 0
      mode:
        input: true
        pulldown: true
    name: "Pulse Counter CH A"
    unit_of_measurement: "Hz"
    update_interval: 100 ms
    filters:
      - multiply: 0.01666667
      - round: 0


  - platform: pulse_counter
    id: pulse_counter_b
    pin:
      number: 1
      mode:
        input: true
        pulldown: true
    name: "Pulse Counter CH B"
    unit_of_measurement: "Hz"
    update_interval: 100 ms
    filters:
      - multiply: 0.01666667
      - round: 0


globals:
  # Startzeitpunkte (ms), 0 = nicht aktiv
  - id: a_start_ms
    type: uint32_t
    restore_value: no
    initial_value: '0'
  - id: b_start_ms
    type: uint32_t
    restore_value: no
    initial_value: '0'

  # damit nicht dauernd neu getriggert wird, solange Signal oben bleibt
  - id: a_armed
    type: bool
    restore_value: no
    initial_value: 'true'
  - id: b_armed
    type: bool
    restore_value: no
    initial_value: 'true'

interval:
  - interval: 200ms
    then:
      - lambda: |-
          const float fa = id(pulse_counter_a).state;
          const float fb = id(pulse_counter_b).state;

          const float tha = id(freq_threshold_ch_a).state;
          const float thb = id(freq_threshold_ch_b).state;

          const uint32_t ta = (uint32_t) id(switching_time_ch_a).state;
          const uint32_t tb = (uint32_t) id(switching_time_ch_b).state;

          const uint32_t now = millis();

          // --- Channel A: wenn fa > tha fÃ¼r ta ms => Switch AUS
          if (fa > tha) {
            if (id(a_armed)) {
              if (id(a_start_ms) == 0) id(a_start_ms) = now;
              if ((uint32_t)(now - id(a_start_ms)) >= ta) {
                id(switch_ab).turn_on();
                id(a_armed) = false;   // erst wieder aktivieren, wenn fa wieder <= tha war
                id(a_start_ms) = 0;
              }
            }
          } else {
            id(a_start_ms) = 0;
            id(a_armed) = true;        // wieder "armed", sobald wieder unter Schwellwert
          }

          // --- Channel B: wenn fb > thb fÃ¼r tb ms => Switch AN
          if (fb > thb) {
            if (id(b_armed)) {
              if (id(b_start_ms) == 0) id(b_start_ms) = now;
              if ((uint32_t)(now - id(b_start_ms)) >= tb) {
                id(switch_ab).turn_off();
                id(b_armed) = false;
                id(b_start_ms) = 0;
              }
            }
          } else {
            id(b_start_ms) = 0;
            id(b_armed) = true;
          }
